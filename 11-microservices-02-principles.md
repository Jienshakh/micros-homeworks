
# Домашнее задание к занятию «Микросервисы: принципы»

Вы работаете в крупной компании, которая строит систему на основе микросервисной архитектуры.
Вам как DevOps-специалисту необходимо выдвинуть предложение по организации инфраструктуры для разработки и эксплуатации.

## Задача 1: API Gateway 

Предложите решение для обеспечения реализации API Gateway. Составьте сравнительную таблицу возможностей различных программных решений. На основе таблицы сделайте выбор решения.

Решение должно соответствовать следующим требованиям:
- маршрутизация запросов к нужному сервису на основе конфигурации,
- возможность проверки аутентификационной информации в запросах,
- обеспечение терминации HTTPS.

Обоснуйте свой выбор.

## Сравнительная таблица API Gateway

| Критерий | NGINX | Kong | Apache APISIX | Traefik | AWS API Gateway |
|----------|-------|------|--------------|---------|-----------------|
| **Маршрутизация** | Отличная, гибкая конфигурация | Отличная, декларативная | Отличная, динамическая | Отличная, автоматическая | Хорошая, облачная |
| **Аутентификация** | Базовая (Basic/JWT через subrequests) | Плагины (JWT, OAuth2, Key-auth) | Плагины (JWT, Key-auth, OpenID) | Middleware (JWT, Basic) | Встроенная (Cognito, Lambda) |
| **HTTPS терминация** | Отличная (Let's Encrypt через certbot) | Есть (через плагины) | Есть | Автоматическая (Let's Encrypt) | Полностью управляемая |
| **Производительность** | Очень высокая | Высокая | Очень высокая | Высокая | Зависит от региона |
| **Отслеживание/метрики** | Базовое (логи) | Плагины (Prometheus, Zipkin) | Плагины (Prometheus, SkyWalking) | Встроенные (Prometheus) | CloudWatch |
| **Цена** | Бесплатный (Open Source) | Бесплатный/Enterprise | Бесплатный | Бесплатный | Pay-per-use |
| **Экосистема** | Огромная, зрелая | Активная, много плагинов | Растущая | Cloud-native фокус | AWS экосистема |
| **Конфигурация** | Файлы (nginx.conf) | DB-based (PostgreSQL) | etcd/DB-based | Dynamic, labels | Web Console/CloudFormation |

## Мой выбор: NGINX

**Обоснование:**

1. **Производительность и надежность** - NGINX проверен годами, обрабатывает миллионы запросов с минимальными ресурсами
2. **Гибкость конфигурации** - Полный контроль через nginx.conf, возможность кастомной логики через auth_request, Lua, JS
3. **HTTPS терминация** - Простая интеграция с Let's Encrypt через certbot, автоматическое обновление сертификатов
4. **Соответствие требованиям**:
   - **Маршрутизация**: мощная система location blocks, rewrite rules, переменные
   - **Аутентификация**: auth_request для проверки через микросервис + поддержка JWT через njs/lua
   - **HTTPS терминация**: встроенная поддержка SSL/TLS, SNI, современные протоколы
5. **Эксплуатационная простота** - Легко развернуть, настроить, мониторить. Docker-образы официальные
6. **Сообщество и документация** - Огромная база знаний, решений для любых кейсов
7. **Cost-effective** - Бесплатен, работает на стандартном железе

**Альтернатива для enterprise:** Kong - если нужны готовые плагины и GUI-управление

---

## Задача 2: Брокер сообщений

Составьте таблицу возможностей различных брокеров сообщений. На основе таблицы сделайте обоснованный выбор решения.

Решение должно соответствовать следующим требованиям:
- поддержка кластеризации для обеспечения надёжности,
- хранение сообщений на диске в процессе доставки,
- высокая скорость работы,
- поддержка различных форматов сообщений,
- разделение прав доступа к различным потокам сообщений,
- простота эксплуатации.

Обоснуйте свой выбор.

## Сравнительная таблица брокеров сообщений

| Критерий | RabbitMQ | Apache Kafka | NATS | Redis Pub/Sub | Apache Pulsar |
|----------|----------|--------------|------|---------------|---------------|
| **Кластеризация** | Есть (репликация очередей) | Есть (partition replication) | Есть (mesh кластер) | Sentinel/Cluster | Есть (сегментированная) |
| **Хранение на диске** | Есть (persistent queues) | Есть (commit log) | Нет (по умолчанию) | Опционально (AOF/RDB) | Есть (сегментированный log) |
| **Скорость** | Средняя (~50K msg/sec) | Очень высокая (>100K msg/sec) | Очень высокая (>1M msg/sec) | Высокая (~200K msg/sec) | Высокая (>100K msg/sec) |
| **Форматы сообщений** | Любые (бинарные) | Бинарные (с сериализацией) | Любые | Любые | Любые |
| **Разграничение прав** | ACL, vhosts | SSL/SASL, ACL (Kafka 2.0+) | Authentication | Парольная защита | Плагины авторизации |
| **Простота эксплуатации** | Средняя | Сложная | Простая | Очень простая | Сложная |
| **Гарантии доставки** | At-least-once | At-least-once | At-most-once | Best-effort | At-least-once |
| **Паттерны** | Queues, Pub/Sub | Pub/Sub (топики) | Pub/Sub, Request/Reply | Pub/Sub | Multi-tenancy |
| **Языки клиентов** | Многие | Многие | Многие | Многие | Многие |

## Мой выбор: Apache Kafka

**Обоснование:**

1. **Кластеризация и надежность** - Встроенная репликация партиций, fault-tolerant, самовосстанавливающийся кластер
2. **Хранение на диске** - Журналируемый commit log, сообщения хранятся заданное время (по TTL)
3. **Высокая скорость** - Линейная масштабируемость, десятки миллионов сообщений в секунду в кластере
4. **Форматы сообщений** - Поддерживает любые форматы через сериализаторы (Avro, JSON, Protobuf)
5. **Разграничение прав** - SASL/SSL аутентификация, ACL начиная с Kafka 2.0, integration с LDAP/Kerberos
6. **Простота эксплуатации** (относительно) - Есть managed решения (Confluent Cloud), инструменты типа kafka-manager
7. **Дополнительные преимущества**:
   - Stream Processing (Kafka Streams, ksqlDB)
   - Коннекторы для интеграции (Kafka Connect)
   - Точный контроль над delivery semantics

**Альтернативы:**
- **RabbitMQ** - если нужны сложные маршрутизации и гарантированная доставка
- **NATS** - если нужна максимальная скорость и простота, но без persistence
- **Redis** - для простых сценариев с умеренными требованиями

**Для микросервисной архитектуры Kafka оптимален, так как:**
1. Единая шина событий для всей системы
2. Возможность реплеи событий для отладки
3. Поддержка event sourcing паттернов
4. Масштабируется линейно с ростом нагрузки


## Задача 3: API Gateway * (необязательная)

### Есть три сервиса:

**minio**
- хранит загруженные файлы в бакете images,
- S3 протокол,

**uploader**
- принимает файл, если картинка сжимает и загружает его в minio,
- POST /v1/upload,

**security**
- регистрация пользователя POST /v1/user,
- получение информации о пользователе GET /v1/user,
- логин пользователя POST /v1/token,
- проверка токена GET /v1/token/validation.

### Необходимо воспользоваться любым балансировщиком и сделать API Gateway:

**POST /v1/register**
1. Анонимный доступ.
2. Запрос направляется в сервис security POST /v1/user.

**POST /v1/token**
1. Анонимный доступ.
2. Запрос направляется в сервис security POST /v1/token.

**GET /v1/user**
1. Проверка токена. Токен ожидается в заголовке Authorization. Токен проверяется через вызов сервиса security GET /v1/token/validation/.
2. Запрос направляется в сервис security GET /v1/user.

**POST /v1/upload**
1. Проверка токена. Токен ожидается в заголовке Authorization. Токен проверяется через вызов сервиса security GET /v1/token/validation/.
2. Запрос направляется в сервис uploader POST /v1/upload.

**GET /v1/user/{image}**
1. Проверка токена. Токен ожидается в заголовке Authorization. Токен проверяется через вызов сервиса security GET /v1/token/validation/.
2. Запрос направляется в сервис minio GET /images/{image}.

### Ожидаемый результат

Результатом выполнения задачи должен быть docker compose файл, запустив который можно локально выполнить следующие команды с успешным результатом.
Предполагается, что для реализации API Gateway будет написан конфиг для NGinx или другого балансировщика нагрузки, который будет запущен как сервис через docker-compose и будет обеспечивать балансировку и проверку аутентификации входящих запросов.
Авторизация
curl -X POST -H 'Content-Type: application/json' -d '{"login":"bob", "password":"qwe123"}' http://localhost/token

**Загрузка файла**

curl -X POST -H 'Authorization: Bearer eyJ0eXAiOiJKV1QiLCJhbGciOiJIUzI1NiJ9.eyJzdWIiOiJib2IifQ.hiMVLmssoTsy1MqbmIoviDeFPvo-nCd92d4UFiN2O2I' -H 'Content-Type: octet/stream' --data-binary @yourfilename.jpg http://localhost/upload

**Получение файла**
curl -X GET http://localhost/images/4e6df220-295e-4231-82bc-45e4b1484430.jpg


[Отчет по выполнению задания 3](./11-microservices-02-principles/readme.md)

---

#### [Дополнительные материалы: как запускать, как тестировать, как проверить](https://github.com/netology-code/devkub-homeworks/tree/main/11-microservices-02-principles)

---

### Как оформить ДЗ?

Выполненное домашнее задание пришлите ссылкой на .md-файл в вашем репозитории.

---
